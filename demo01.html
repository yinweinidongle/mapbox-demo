<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Guides</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js"></script>
<script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js" type="text/javascript"></script>
<link href="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.css" rel="stylesheet">


<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
.address{position: absolute;left: 0;top:0;z-index: 99;color: aliceblue;}
.address>ul{list-style: none;}
.address>ul>li{padding:10px 20px;margin-top: 5px;border: 1px solid #333;text-align: center;cursor: pointer;transition: all 0.4s;}
.address>ul>li:hover{background-color: antiquewhite;color:#333;transform: scale(1.2);}
</style>
</head>
<body>
    <div class="address">
        <ul>
            <li id="wh">wuhu</li>
            <li id="bj">beijing</li>
            <li>shanghai</li>

            <br>
            <br>
            <br>

            <li id="scene">场景</li>
            <li id="daofu">倒伏</li>
            <li id="grid">网格</li>
            <li id="object">其他</li>




        </ul>
    </div>
<div id="map"></div>
<script>
	mapboxgl.accessToken = 'pk.eyJ1IjoieWlud2VpbmlkbmdsZSIsImEiOiJja3EzMHRzbGkwajdvMnBwaTc5d3B4NjNpIn0.VdMv_I1TppI_8sFOH5K9Hg';
    const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        projection: 'globe', // Display the map as a globe, since satellite-v9 defaults to Mercator
        zoom: 1,
        center: [30, 15]
    });

    //设置地图语言
    // const language = 'fr';
    //         // Use setLayoutProperty to set the value of a layout property in a style layer.
    //         // The three arguments are the id of the layer, the name of the layout property,
    //         // and the new property value.
    //         map.setLayoutProperty('label_country', 'text-field', [
    //             'get',
    //             `name:${language}`
    //         ]);



    const start_wh = {
        center: [80, 36],
        zoom: 1,
        pitch: 0,
        bearing: 0
    };
    const end_wh = {
        //31.198367289519844, 118.225453872756574
        center: [118.225453872756574,31.198367289519844],
        //center:[-74.5447, 40.6892],
        zoom: 16,
        bearing: 130,
        pitch: 75
    };

    const end_bj = {
        center: [116.417492,39.881058],
        zoom: 16,
        bearing: 130,
        pitch: 75
    };


    var flying = false;
    let hoveredStateId = null; //鼠标hover网格选中变色


    map.addControl(new mapboxgl.NavigationControl());
    map.scrollZoom.disable();




    //点击按钮，显示/隐藏 图层
    document.getElementById('daofu').addEventListener('click', () => {
        toggleLayer('daofu-show')
        
    });

    document.getElementById('grid').addEventListener('click', () => {
        toggleLayer('outline-show')
        
    });

    document.getElementById('object').addEventListener('click', () => {
        toggleLayer('custom-threebox-model')
    });

    document.getElementById('scene').addEventListener('click', () => {
        toggleLayer('3d-model')
    });

    // 显示或隐藏指定图层的函数
    function toggleLayer(layerId){
        var visibility = map.getLayoutProperty(layerId, 'visibility');

        if (visibility === 'visible') {
            map.setLayoutProperty(layerId, 'visibility', 'none');
        } else {
            map.setLayoutProperty(layerId, 'visibility', 'visible');
        }
    }





    map.on('style.load', () => {
        map.setFog({
            'color': 'rgb(220, 159, 159)', // Pink fog / lower atmosphere
            'high-color': 'rgb(36, 92, 223)', // Blue sky / upper atmosphere
            'horizon-blend': 0.4 // Exaggerate atmosphere (default is .1)
        });

        map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.terrain-rgb'
        });

        map.setTerrain({
            'source': 'mapbox-dem',
            'exaggeration': 1.5
        });

        map.addLayer(customLayer, 'waterway-label');


        //添加wms 服务
        // map.addSource('wms-test-source', {
        //     'type': 'raster',
        //     // use the tiles option to specify a WMS tile source URL
        //     // https://docs.mapbox.comhttps://docs.mapbox.com/style-spec/reference/sources/
        //     'tiles': [
        //         'https://map.zkzngz.com:6443/arcgis/services/sanshan/20230710sanshan/MapServer/WMSServer?version=1.1.0&request=GetMap&layers=0&srs=EPSG%3A4326&styles=&format=image%2Fpng&TRANSPARENT=TRUE&BBOX='
                
        //     ],
        //     'tileSize': 256
        // });

        // map.addLayer(
        //     {
        //         'id': 'wms-test-layer',
        //         'type': 'raster',
        //         'source': 'wms-test-source',
        //         'paint': {}
        //     },
        // );


        map.addSource('wms-test-source', {
            'type': 'raster',
            // use the tiles option to specify a WMS tile source URL
            // https://docs.mapbox.comhttps://docs.mapbox.com/style-spec/reference/sources/
            'tiles': [
                'https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&srs=EPSG:3857&transparent=true&width=256&height=256&layers=Natural2015'
            ],
            'tileSize': 256
        });
        map.addLayer(
            {
                'id': 'wms-test-layer',
                'type': 'raster',
                'source': 'wms-test-source',
                'paint': {}
            },
            // 'building' // Place layer under labels, roads and buildings.
        );


        //add a geojson data
        map.addSource('outline', {
            type: 'geojson',
            // Use a URL for the value for the `data` property.
            data: './assets/data.geojson'
        });

        map.addLayer({
            'id': 'outline-show',
            'type': 'fill',
            'source': 'outline',
            'layout': {},
            'paint': {
                'fill-color': {
                    property: "mean", // this will be your density property form you geojson
                        stops: [
                            [0,"transparent"],
                            [0.22, "green"],
                            [0.40, "yellow"],
                            [0.822, "red"],
                            [1, "red"]
                        ]},
                'fill-opacity': [
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    1,
                    0.5
                ]
                }

        });

        map.addSource('daofu', {
            type: 'geojson',
            // Use a URL for the value for the `data` property.
            data: './assets/daofu.json'
        });

        map.addLayer({
            'id': 'daofu-show',
            'type': 'fill',
            'source': 'daofu',
            'layout': {},
            'paint': {
                'fill-color': "red",
                'fill-opacity': 1
                }

        });

        map.on('click', 'outline-show', (e) => {
            new mapboxgl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(e.features[0].properties.mean)
                .addTo(map);
        });

        // Change the cursor to a pointer when
        // the mouse is over the states layer.
        map.on('mouseenter', 'outline-show', () => {
            map.getCanvas().style.cursor = 'pointer';
        });

       
         // When the user moves their mouse over the state-fill layer, we'll update the
        // feature state for the feature under the mouse.
        map.on('mousemove', 'outline-show', (e) => {
            if (e.features.length > 0) {
                if (hoveredStateId) {
                    map.setFeatureState(
                        {source: 'outline', id: hoveredStateId},
                        {hover: false}
                    );
                }
                hoveredStateId = e.features[0].id;
                map.setFeatureState(
                    {source: 'outline', id: hoveredStateId},
                    {hover: true}
                );
            }
        });

        // When the mouse leaves the state-fill layer, update the feature state of the
        // previously hovered feature.
        map.on('mouseleave', 'outline-show', () => {
            if (hoveredStateId) {
                map.setFeatureState(
                    {source: 'outline', id: hoveredStateId},
                    {hover: false}
                );
            }
            hoveredStateId = null;
            map.getCanvas().style.cursor = '';
        });
        
        //fly end callback
        map.on('flystart', function(){
            flying = true;
            console.log('fly start')
        });
        map.on('flyend', function(){
            flying = false;
            console.log('fly end')
            //添加沙盘效果
            let timer = setInterval(()=>{
                let bearing = map.getBearing()
                bearing = bearing - 0.5
                map.setBearing(bearing)
                console.log(bearing)
                if(bearing<-10){
                    clearInterval(timer)
                }

            },10)

        });

        




    });



    // eslint-disable-next-line no-undef
    const tb = (window.tb = new Threebox(
        map,
        map.getCanvas().getContext('webgl'),
        {
            defaultLights: true
        }
    ));

    map.on('style.load', () => {

        var time = 0
        var materialShader = null 
        map.addLayer({
            id: 'custom-threebox-model',
            type: 'custom',
            renderingMode: '3d',
            onAdd: function () {
                // Creative Commons License attribution:  Metlife Building model by https://sketchfab.com/NanoRay
                // https://sketchfab.com/3d-models/metlife-building-32d3a4a1810a4d64abb9547bb661f7f3
                const scale = 3.2;
                const options = {
                    obj: 'https://docs.mapbox.com/mapbox-gl-js/assets/metlife-building.gltf',
                    type: 'gltf',
                    scale: { x: scale, y: scale, z: 2.7 },
                    units: 'meters',
                    rotation: { x: 90, y: -90, z: 0 }
                };

                const options1 = {
                    obj:'./assets/fish.glb',
                    type: 'glb',
                    scale: { x: 50, y: 50, z: 50 },
                    units: 'meters',
                    rotation: { x: 90, y: -90, z: 0 }
                };

                tb.loadObj(options, (model) => {
                    model.setCoords([116.417492,39.881058]);
                    model.setRotation({ x: 0, y: 0, z: 241 });
                    tb.add(model);
                });

                tb.loadObj(options1, (model) => {
                    model.setCoords([116.417492,39.881058]);
                    model.setRotation({ x: 0, y: 0, z: 241 });
                    tb.add(model);
                    // if (!e.detail.isPlaying) {
                    //     obj.playAnimation({ animation: 0, duration: 1000 });
                    // }
                });

                // initialize geometry and material of our cube object
                var geometry = new THREE.BoxGeometry(2, 2, 2);

                var redMaterial = new THREE.MeshPhongMaterial( {
                    color: 0x009900, 
                    side: THREE.DoubleSide
                });

                var cube = new THREE.Mesh(geometry, redMaterial);
                cube = tb.Object3D({obj: cube})
                    .setCoords([118.225453872756574,31.198367289519844, 10])

                tb.add(cube)


                //add a plane with shader materail
                // 定义着色器
                const vertex = `
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
                `;

                const fragment = `
                varying vec2 vUv;
                uniform float uTime;
                void main() {
                float dist = length(vUv - vec2(0.5));
                float radius = 0.5 * (sin(uTime) * 0.5 + 0.5);
                vec3 color = vec3(step(radius, dist));
                gl_FragColor = vec4(color, 1.0);
                }
                `;

                // 创建材质
                materialShader = new THREE.ShaderMaterial({
                    uniforms: { 
                        uTime: 
                        { value: 0 } 
                    },
                    vertexShader: vertex,
                    fragmentShader: fragment
                });
                
                // 创建平面
                var geometryShader = new THREE.PlaneGeometry(10, 10);
                var mesh = new THREE.Mesh(geometryShader, materialShader);
                mesh = tb.Object3D({obj: mesh})
                    .setCoords([118.225453872756574,31.198367289519844, 50])

                tb.add(mesh)
            },

            render: function () {
                time += 0.05;
                materialShader.uniforms.uTime.value = time;
                tb.update();
            }
        });



    });



    // The following values can be changed to control rotation speed:

    // At low zooms, complete a revolution every two minutes.
    const secondsPerRevolution = 240;
    // Above zoom level 5, do not rotate.
    const maxSpinZoom = 5;
    // Rotate at intermediate speeds between zoom levels 3 and 5.
    const slowSpinZoom = 3;

    let userInteracting = false;
    const spinEnabled = true;

    function spinGlobe() {
        const zoom = map.getZoom();
        if (spinEnabled && !userInteracting && zoom < maxSpinZoom) {
            let distancePerSecond = 360 / secondsPerRevolution;
            if (zoom > slowSpinZoom) {
                // Slow spinning at higher zooms
                const zoomDif =
                    (maxSpinZoom - zoom) / (maxSpinZoom - slowSpinZoom);
                distancePerSecond *= zoomDif;
            }
            const center = map.getCenter();
            center.lng -= distancePerSecond;
            // Smoothly animate the map over one second.
            // When this animation is complete, it calls a 'moveend' event.
            map.easeTo({ center, duration: 1000, easing: (n) => n });
        }
    }

    // Pause spinning on interaction
    map.on('mousedown', () => {
        userInteracting = true;
    });
    map.on('dragstart', () => {
        userInteracting = true;
    });

    // When animation is complete, start spinning if there is no ongoing interaction
    map.on('moveend', () => {
        spinGlobe();
        if(flying){
            map.fire('flyend');
        }
        
    });

    //监听map zoom级别
    map.on('zoomend',function(){
        var currentZoom = map.getZoom();
        console.log("Zoom level",currentZoom);
    })

    spinGlobe();




    //fly from start to end 
    let isAtStart = true;

    document.getElementById('wh').addEventListener('click', () => {
        // depending on whether we're currently at point a or b,
        // aim for point a or b
        const target = isAtStart ? end_wh : start_wh;
        isAtStart = !isAtStart;

        map.flyTo({
            ...target, // Fly to the selected target
            duration: 12000, // Animate over 12 seconds
            essential: true // This animation is considered essential with
            //respect to prefers-reduced-motion
        });
        map.fire('flystart');
    });


    document.getElementById('bj').addEventListener('click', () => {
        // depending on whether we're currently at point a or b,
        // aim for point a or b
        const target = isAtStart ? end_bj : start_wh;
        isAtStart = !isAtStart;

        map.flyTo({
            ...target, // Fly to the selected target
            duration: 12000, // Animate over 12 seconds
            essential: true // This animation is considered essential with
            //respect to prefers-reduced-motion
        });
        map.fire('flystart');
    });


    // Add a new Marker.
    const marker = new mapboxgl.Marker({
        color: '#F84C4C' // color it red
    });

    marker.setLngLat([
            118.23100358842,
            31.196365862
        ]);

    marker.addTo(map);


    //add 3d gltf model
     // parameters to ensure the model is georeferenced correctly on the map
     const modelOrigin = [118.23100358842, 31.196365862];
    const modelAltitude = 150;
    const modelRotate = [Math.PI / 2, 0, 0];

    const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
        modelOrigin,
        modelAltitude
    );

    // transformation parameters to position, rotate and scale the 3D model onto the map
    const modelTransform = {
        translateX: modelAsMercatorCoordinate.x,
        translateY: modelAsMercatorCoordinate.y,
        translateZ: modelAsMercatorCoordinate.z,
        rotateX: modelRotate[0],
        rotateY: modelRotate[1],
        rotateZ: modelRotate[2],
        /* Since the 3D model is in real world meters, a scale transform needs to be
         * applied since the CustomLayerInterface expects units in MercatorCoordinates.
         */
        scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
    };

    const THREE = window.THREE;

    // configuration of the custom layer for a 3D model per the CustomLayerInterface
    const customLayer = {
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd: function (map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();

            let mixer;
            let parameters;
            const materials = [];
            const parts = []

			const clock = new THREE.Clock();

            // create two three.js lights to illuminate the model
            const directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(0, -70, 100).normalize();
            this.scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff);
            directionalLight2.position.set(0, 70, 100).normalize();
            this.scene.add(directionalLight2);

            // use the three.js GLTF loader to add the 3D model to the three.js scene
            const loader = new THREE.GLTFLoader();

            const  dracoLoader = new THREE.DRACOLoader()
            dracoLoader.setDecoderPath('./libs/draco/gltf/')
            dracoLoader.setDecoderConfig({ type: 'js' })
            dracoLoader.preload()
            loader.setDRACOLoader(dracoLoader)

            loader.load(
                './assets/LittlestTokyo.glb',
                (gltf) => {
                    
                    this.scene.add(gltf.scene);
                    gltf.scene.scale.set(0.5,0.5,0.5)
                    mixer = new THREE.AnimationMixer( gltf.scene );
				    mixer.clipAction( gltf.animations[ 0 ] ).play();
                }
            );

            loader.load(
                './assets/fish.glb',
                (gltf) => {
                    console.log("fishpon",gltf)
                    //this.scene.add(gltf.scene);
                    //gltf.scene.scale.set(50,50,50)
                    mixer = new THREE.AnimationMixer( gltf.scene );
				    mixer.clipAction( gltf.animations[ 0 ] ).play();
                }
            );




            //下雪特效
            const geometry = new THREE.BufferGeometry();
				const vertices = [];

				const textureLoader = new THREE.TextureLoader();

				const assignSRGB = ( texture ) => {

					texture.colorSpace = THREE.SRGBColorSpace;

				};

				const sprite1 = textureLoader.load( 'assets/sprites/snowflake1.png', assignSRGB );
				const sprite2 = textureLoader.load( 'assets/sprites/snowflake2.png', assignSRGB );
				const sprite3 = textureLoader.load( 'assets/sprites/snowflake3.png', assignSRGB );
				const sprite4 = textureLoader.load( 'assets/sprites/snowflake4.png', assignSRGB );
				const sprite5 = textureLoader.load( 'assets/sprites/snowflake5.png', assignSRGB );

				for ( let i = 0; i < 1000; i ++ ) {

					const x = Math.random() * 2000 - 1000;
					const y = Math.random() * 2000 - 1000;
					const z = Math.random() * 2000 - 1000;

					vertices.push( x, y, z );

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

				parameters = [
					[[ 1.0, 0.2, 0.5 ], sprite2, 20 ],
					[[ 0.95, 0.1, 0.5 ], sprite3, 15 ],
					[[ 0.90, 0.05, 0.5 ], sprite1, 10 ],
					[[ 0.85, 0, 0.5 ], sprite5, 8 ],
					[[ 0.80, 0, 0.5 ], sprite4, 5 ]
				];

				for ( let i = 0; i < parameters.length; i ++ ) {

					const color = parameters[ i ][ 0 ];
					const sprite = parameters[ i ][ 1 ];
					const size = parameters[ i ][ 2 ];

					materials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
					materials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );

					const particles = new THREE.Points( geometry, materials[ i ] );

					particles.rotation.x = Math.random() * 6;
					particles.rotation.y = Math.random() * 6;
					particles.rotation.z = Math.random() * 6;
                    parts.push(particles);

					this.scene.add( particles );

				}









            function animate(){
                requestAnimationFrame(animate);

                const time = Date.now() * 0.00005;

               

                for ( let i = 0; i < materials.length; i ++ ) {

                    parts[i].rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );

                    const color = parameters[ i ][ 0 ];

                    const h = ( 360 * ( color[ 0 ] + time ) % 360 ) / 360;
                    materials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ], THREE.SRGBColorSpace );

                }


                if(mixer){
                    
                    mixer.update(clock.getDelta())
                }
                map.triggerRepaint()
            }

            animate()

            this.map = map;

            // use the Mapbox GL JS map canvas for three.js
            this.renderer = new THREE.WebGLRenderer({
                canvas: map.getCanvas(),
                context: gl,
                antialias: true
            });

            this.renderer.autoClear = false;


            

        },
        render: function (gl, matrix) {
            const rotationX = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(1, 0, 0),
                modelTransform.rotateX
            );
            const rotationY = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(0, 1, 0),
                modelTransform.rotateY
            );
            const rotationZ = new THREE.Matrix4().makeRotationAxis(
                new THREE.Vector3(0, 0, 1),
                modelTransform.rotateZ
            );

            const m = new THREE.Matrix4().fromArray(matrix);
            const l = new THREE.Matrix4()
                .makeTranslation(
                    modelTransform.translateX,
                    modelTransform.translateY,
                    modelTransform.translateZ
                )
                .scale(
                    new THREE.Vector3(
                        modelTransform.scale,
                        -modelTransform.scale,
                        modelTransform.scale
                    )
                )
                .multiply(rotationX)
                .multiply(rotationY)
                .multiply(rotationZ);

            this.camera.projectionMatrix = m.multiply(l);
            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();



        },

        
        
    };



    //add geojson data


    






    
</script>

</body>
</html>